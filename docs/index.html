
<!DOCTYPE html>
<html lang="sk-SK">
<head>
	<!-- Primary Meta Tags -->
	<title>Hladinomer - Arduino / ESP8266 / ESP32 - výška hladiny vody v studni, nádrži, žumpe</title>
	<meta name="description" content="Hladinomer - Monitor výšky hladiny vody postavený na platforme Arduino, ESP8266, ESP32. Meranie ultrazvukovým senzorom HC-SR04 / JSN-SR04T. Odosielanie dát cez Ethernet, WiFi, Sigfox. Meranie výšky hladiny vody v studni, žumpe.">
	<meta name="keywords" content="hladinomer, studňa, žumpa, septik, výška, hladina, monitor, meranie, ultrazvuk, plavákový, optický, hydrostatický, tlakový, ponorný, 20ma, 5V, ESP8266, WiFi, Arduino, Sigfox, IoT, Ethernet">
	<meta name="news_keywords" content="hladinomer, studňa, žumpa, septik, výška, hladina, monitor, meranie, ultrazvuk, plavákový, optický, hydrostatický, tlakový, ponorný, 20ma, 5V, ESP8266, WiFi, Arduino, Sigfox, IoT, Ethernet">	
<!-- Open Graph / Facebook -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://martinius96.github.io/hladinomer-studna-scripty/">
	<meta property="og:title" content="Hladinomer - Arduino / ESP8266 / ESP32 - výška hladiny vody v studni">
	<meta property="og:description" content="Hladinomer postavený na platforme Arduino, ESP8266, ESP32. Meranie ultrazvukovým senzorom HC-SR04 / JSN-SR04T. Odosielanie dát cez Ethernet, WiFi, Sigfox. Meranie výšky hladiny vody v studni, žumpe.">
	<meta property="og:image" content="">

	<!-- Twitter -->
	<meta property="twitter:card" content="summary_large_image">
	<meta property="twitter:url" content="https://martinius96.github.io/hladinomer-studna-scripty/">
	<meta property="twitter:title" content="Hladinomer - Arduino / ESP8266 / ESP32 - výška hladiny vody v studni">
	<meta property="twitter:description" content="Hladinomer postavený na platforme Arduino, ESP8266, ESP32. Meranie ultrazvukovým senzorom HC-SR04 / JSN-SR04T. Odosielanie dát cez Ethernet, WiFi, Sigfox. Meranie výšky hladiny vody v studni, žumpe.">
	<meta property="twitter:image" content="">
	
	<link rel="icon" type="image/png" href="https://martinius96.github.io/termostat-ethernet/favicon.png">
	<link rel="sitemap" type="application/xml" title="Sitemap" href="sitemap.xml" />
	<meta name="google-site-verification" content="UwZZh2EXv3iWUAi_1Z0hLxVCz6ySJ4UdY_BPoLtejwo" />    	
	<meta property='fb:admins' content='100001242570317'>
    	<meta charset="utf-8">
    	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
	<script type="text/javascript">
    		window.smartlook||(function(d) {
    			var o=smartlook=function(){ o.api.push(arguments)},h=d.getElementsByTagName('head')[0];
    			var c=d.createElement('script');o.api=new Array();c.async=true;c.type='text/javascript';
    			c.charset='utf-8';c.src='https://rec.smartlook.com/recorder.js';h.appendChild(c);
    		})(document);
    		smartlook('init', 'db50efe9fff280a17db52b82be221240cbbd3dbe');
	</script>    
</head>
<body>
	<div class="container">
  		<div class="row">
    			<div class="col-sm-12">
<nav class="navbar navbar-inverse">
  <div class="container-fluid">
    <ul class="nav navbar-nav">
      	<li class="active"><a href="index.html">Hladinomer</a></li>
	<li><a href="zrazkomer.html">Zrážkomer</a></li>
	<li><a href="zapojenie.html">Zapojenie</a></li>   
	<li class=""><a href="json_client.html">JSON client</a></li>   
      	<li><a href="kontakt.html">Kontakt</a></li>
	<a href="en/index.html"><img src="https://www.flaticon.com/svg/static/icons/svg/299/299688.svg" alt="English.png, 2,2kB" title="English" height="32" width="32"></a>
            <img src="https://i.imgur.com/YAi45JJ.png" alt="Arduino Core" title="Arduino Core" height="32" width="32">
            <img src="https://i.imgur.com/2pOgsYZ.png" alt="Espressif IoT Development framework (ESP-IDF)" title="Espressif IoT Development framework (ESP-IDF)" height="32" width="32">
            <img src="https://i.imgur.com/Lsk36Zb.png" alt="Sigfox IoT network supported" title="Sigfox IoT network supported" height="32" width="32">
    </ul>
  </div>
</nav>  
				<div class="alert alert-success">
					<strong>Zdrojové kódy pre Arduino, ESP8266, ESP32, knižnica NewPing: </strong><a href="https://github.com/martinius96/hladinomer-studna-scripty/">Github repozitár projektu</a>
				</div>	
				<div class="alert alert-success">
					<strong><font color="red">Vyskúšajte projekt Hladinomer zdarma s vašim hardvérom: </strong><a href="http://arduino.clanweb.eu/studna_s_prekladom/">TU</font></a>
				</div>	
				<div class="alert alert-info">
					<strong>Od 4. Júna 2021 dostupná implementácia pre ESP32 vo frameworku ESP-IDF v4.2 (4.0 kompatibilné)</strong>
				</div>
				<div class="alert alert-danger">
					<strong>Kontakt na autora projektu: </strong>martinius96@gmail.com
				</div>
<span class="label label-default">Arduino</span>
<span class="label label-primary">Ethernet</span>
<span class="label label-success">Wiznet W5100 / W5500</span>
<span class="label label-info">ESP8266</span>
<span class="label label-warning">ESP32</span>
<span class="label label-danger">Ultrasonic</span>
<span class="label label-default">HC-SR04</span>
<span class="label label-primary">JSN-SR04T</span>
<span class="label label-info">Sigfox</span>				
<hr>
<center> 
	<h3>Riadiace mikrokontroléry pre projekt Hladinomer</h3>
</center>	
     <hr>				
<div class="row">
<div class="col-sm-3"><center><img src="https://i.imgur.com/wtnzKqO.png" width="128px" height="128px" style="border-radius: 50%;" alt="Riadiaci mikrokontróler Arduino Uno pre termostat" title="Riadiaci mikrokontróler Arduino Uno pre termostat"><br><b>Arduino Uno / Nano</b></center></div>
<div class="col-sm-3"><center><img src="https://i.imgur.com/koSyFuW.png" width="128px" height="128px" style="border-radius: 50%;" alt="Riadiaci mikrokontróler NodeMCU v2 / v3 Lolin - ESP8266-12E / ESP8266-12F" title="Riadiaci mikrokontróler NodeMCU v2 / v3 Lolin - ESP8266-12E / ESP8266-12F"><br><b>NodeMCU v3 Lolin</b></center></div>
<div class="col-sm-3"><center><img src="https://i.imgur.com/FV9xi6K.png" width="128px" height="128px" style="border-radius: 50%;" alt="Riadiaci mikrokontróler Wemos D1 Mini - ESP8266-12E / ESP8266-12F" title="Riadiaci mikrokontróler Wemos D1 Mini - ESP8266-12E / ESP8266-12F"><br><b>Wemos D1 Mini</b></center></div>
<div class="col-sm-3"><center><img src="https://i.imgur.com/BczG03b.png" width="128px" height="128px" style="border-radius: 50%;" alt="Riadiaci mikrokontróler ESP32 Devkit V1 - ESP-WROOM-32 / ESP32-S" title="Riadiaci mikrokontróler ESP32 Devkit V1 - ESP-WROOM-32 / ESP32-S"><br><b>ESP32 DevKit V1</b></center></div>
</div>	
<hr>	
<center> 
	<h3>Moduly prenosových technológii Ethernet a Sigfox pre projekt Hladinomer</h3>
</center>
<hr>
<div class="row">
<div class="col-sm-2"><center><img src="https://i.imgur.com/aaS35X2.png" width="128px" height="128px" style="border-radius: 50%;" alt="Ethernet shield Wiznet W5100" title="Ethernet shield Wiznet W5100"><br><b>Ethernet shield Wiznet W5100</b></center></div>
<div class="col-sm-2"><center><img src="https://i.imgur.com/mz4dhRA.png" width="128px" height="128px" style="border-radius: 50%;" alt="Ethernet modul Wiznet W5500" title="Ethernet modul Wiznet W5500"><br><b>Ethernet modul Wiznet W5500</b></center></div>
<div class="col-sm-4"><center><img src="https://i.imgur.com/LhpZGxj.png" width="128px" height="128px" style="border-radius: 50%;" alt="Ethernet modul Wiznet USR-ES1" title="Ethernet modul Wiznet USR-ES1"><br><b>Ethernet modul Wiznet USR-ES1</b></center></div>
<div class="col-sm-2"><center><img src="https://i.imgur.com/yIZEKct.png" width="128px" height="128px" style="border-radius: 50%;" alt="Ethernet modul MicroChip ENC28J60" title="Ethernet modul MicroChip ENC28J60"><br><b>Ethernet modul ENC28J60</b></center></div>
<div class="col-sm-2"><center><img src="https://i.imgur.com/r2Q4faF.png" width="128px" height="128px" style="border-radius: 50%;" alt="Sigfox Wisol modem - IoT LPWAN Node 868 MHz" title="Sigfox Wisol modem - IoT LPWAN Node 868 MHz"><br><b>Sigfox Node Modem</b></center></div>
</div>
<hr>
<center> 
	<h3>Podporované a testované ultrazvukové senzory pre záznam výšky hladiny vody</h3>
</center>	
     <hr>				
<div class="row">
<div class="col-sm-3"><center><img src="https://i.imgur.com/t4HDpjA.png" width="128px" height="128px" style="border-radius: 50%;" alt="Ultrazvukový senzor vzdialenosti HC-SR04" title="Ultrazvukový senzor vzdialenosti HC-SR04"><br><b>HC-SR04</b></center></div>
<div class="col-sm-3"><center><img src="https://i.imgur.com/DlWRbhK.png" width="128px" height="128px" style="border-radius: 50%;" alt="Ultrazvukový vodotesný senzor vzdialenosti JSN-SR04T" title="Ultrazvukový vodotesný senzor vzdialenosti JSN-SR04T"><br><b>JSN-SR04T</b></center></div>		
<div class="col-sm-3"><center><img src="https://i.imgur.com/MuTRnZu.png" width="128px" height="128px" style="border-radius: 50%;" alt="Ultrazvukový senzor vzdialenosti HY-SRF05" title="Ultrazvukový senzor vzdialenosti HY-SRF05"><br><b>HY-SRF05</b></center></div>
<div class="col-sm-3"><center><img src="https://i.imgur.com/P4HvyLn.png" width="128px" height="128px" style="border-radius: 50%;" alt="Ultrazvukový senzor vzdialenosti URM07 ovládaný cez UART" title="Ultrazvukový senzor vzdialenosti URM07 ovládaný cez UART"><br><b>URM07</b></center></div>		
</div>					
<hr><center><h2>Hladinomer - Arduino / ESP8266 / ESP32</h2></center><hr>
<p style="text-align: justify;">
Projekt hladinomer (monitor výšky hladiny vody) je tvorený centrálnym webovým rozhraním, ktoré slúži na vizualizáciu nameraných údajov o výške hladiny vody v reálnom čase, ale aj historicky v čase cez tabuľkovú / grafickú reprezentáciu čiarovými grafmi.
Webové rozhranie je responzíve, dokáže sa prispôsobiť každej obrazovke a rozlíšeniu zariadenia. 
Dáta sú tak čitateľné na hodinkách, smartfónoch, počítačoch, Smart TV a iných zariadeniach.
Webové rozhranie projektu využíva backend napísaný v jazyku PHP, ktorý dokáže spracovať prichádzajúce dáta z požiadavky metódy HTTP POST.
Následne vykonáva korekciu nameranej výšky hladiny na skutočnú na základe známej hĺbke studne.
Vypočíta aj objem studne pre dané meranie na základe známeho priemeru studne studne.
Hĺbku a priemer studne do systému vkladá používateľ na základe jeho studne.
Dáta sa na webserver odosiela mikrokontróler, ktorý vykonáva merania každých 300 sekúnd - t.j. 5 minút, respektíve v prípade prenosu cez IoT sieť Sigfox sa dáta odosielajú každých 11 minút.
<b>Meranie výšky hladiny vody sa realizuje s využitím ultrazvukových senzorov</b> - HC-SR04, alebo jeho vodotesnej varianty JSN-SR04T, prípadne UART senzorom URM07 (SKU SEN0153) - dostupný iba v špeciálnej verzii projektu Hladinomer. Dokáže merať vzdialenosť až 750 cm, z dôvodu veľkého detekčného uhla sa nehodí do veľkého množstva studní... 
Princíp merania ultrazvukových senzorov je vyslanie signálu Trigger s dĺžkou 10μs (mikrosekúnd) a na základe času, kedy sa signál vráti do prijímača - Echo je možné dopočítať vzdialenosť medzi senzorom a hladinou.
Dôležitým parametrom u oboch ultrazvukových senzorov je šírka lúča, inými slovami detekčná charakteristika.
Senzor HC-SR04 má 15° detekčnú charakteristiku. Lúč je relatívne úzky a senzor je tak vhodný aj pre užšie studne a nádrže, avšak nie je vodotesný a má vysoké riziko korózie (oxidácie). 
Z toho dôvodu je ho vhodné umiestniť nad studňu. 
Vodotesný senzor JSN-SR04T má detekčnú charakteristiku 60 až 75°, čo ho nedovoľuje použiť v úzkych studniach, nakoľko sa lúč so vzdialenosťou veľmi rozširuje a je potrebná studňa s priemerom niekoľko jednotiek metrov (6 metrov pri 4,5 hĺbke studne).
Meranie ultrazvukovou metódou je vhodné pre meranie výšky hladiny pitnej, úžitkovej i odpadovej vody.
Systém a ultrazvukové senzory sú bezúdržbové.
Stačí zapojiť, nahrať programovú implementáciu a prevádzkovať.
Ultrazvukové senzory je možné využiť aj pre meranie výšku materiálu v rôznych aplikáciách. 
V prípade štvrcovej studne sa do priemeru dosádza priemer vpísanej kružnice, ktorá bude tvoriť referenčnú hodnotu vodného valca a objem studne.
Maximálna merateľná výška hladiny (úrovne) senzormi je cca 400 až 450cm (známe z datasheetu).
</p>
<hr><center><h4>Video demonštrácia webového rozhrania - Hladinomer:</h4></center><hr>
<center><iframe width="75%" height="315" src="https://www.youtube.com/embed/ZihXBGEzcT0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center>
<hr><center><h4>Ultrazvukové senzory sú vhodné do:</h4></center><hr>
<li>Kopaných studní</li>
<li>Septikov a žúmp</li>
<li>Plastových nádrží na dažďovú vodu</li>
<li>Zásobníkov</li>
<hr><center><h4>Ultrazvukové senzory <font color="red">nie</font> sú vhodné do:</h4></center><hr>
<li>Vŕtaných studní</li>
<li>Potrubí a rúr</li>
<li>Do studní s neustálenou hladinou</li>
<hr><center><h3>Princíp fungovania hladinomera - Bloková schéma</h3></center><hr>
<center><img src="https://i.imgur.com/VCobc6h.jpg" style="display: block; max-width: 100%; height: auto;" alt="Hladinomer do žumpy, septiku, studne, princíp merania - ultrazvukový senzor vzdialenosti" title="Hladinomer do žumpy, septiku, studne, princíp merania - ultrazvukový senzor vzdialenosti"></center>
<p style="text-align: justify;">
Webové rozhranie využíva trigonometriu pre odhad merateľnej maximálnej hĺbky studne pri známom priemere studne (ďalší parameter pre výpočet objemu studne). 
Používateľovi vie tak webové rozhranie dopočítať, do akej maximálnej hĺbky studne je každý zo senzorov vhodný na základe jeho charakteristiky. 
Projekt je tak jednoduchý na použitie aj pre laikov, ktorí nevedia, ktorý senzor je pre aplikáciu v ich studni vhodnejší.
Dôležitú úlohu v systéme zohráva aj použitý mikrokontróler. Pre projekt sa využila platforma Arduino (Uno) spojená s Ethernet modulom / shieldom z rady Wiznet model W5100, respektíve W5500, ktorý zabezpečoval HTTP konektivitu a umožnil mikrokontroléru prenos dát do vzdialeného webového rozhrania na internete.
Nakoľko je hladinomer exteriérovým projektom, mnoho používateľov by si obľúbilo aj možnosť využitia WiFi platformy bez nutnosti pritiahnutia Ethernet konektivity až k studni. 
WiFi platformy od Espressif Systems - ESP8266 a ESP32, ktoré sú v projekte použité umožňujú prevádzku v rôznych režimoch - StandBy, Deep Sleep (hlboký spánok s vypnutým WiFi modemom), StandBy + OTA - umožňuje vzdialene prostredníctvom LAN siete nahrať do dosky nový firmvér priamo z prostredia Arduino IDE.
Na vyžiadanie možno vytvoriť aj Remote OTA aktualizáciu, ktorá je distribuovaná vzdialene cez internet z webservera, možno využiť Github repozitár, ktorý dokáže v RAW formáte .bin aktualizáciu distribuovať klientovi.
Pre Deep Sleep prevádzkový režim existuje pri platformy ESP8266 upravená schéma zapojenia, ktorá využíva pre prebudenie mikrokontroléru WAKE signál, ktorý je privedený na RST.
Zároveň toto zapojenie neumožňuje aktualizáciu programu bez odpojenia tejto prepojky.
Pre ESP32 sa využíva Deep Sleep režim s využitím RTC timera, ktorý ESP prebudí po určitom čase.
Platformy dokážu s webovým rozhraním komunikovať po HTTP, ale aj HTTPS protokole. Platforma ESP8266 využíva odtlačok (fingeprint) verejného kľúča webservera v SHA1 formáte, vyžaduje však častejší renew, nakoľko platí maximálne rok, respektíve 2 roky. 
Mikrokontróler z rady ESP32 využíva pre HTTPS spojenie certifikát koreňovej certifikačnej autority, ktorá pre webserver vydala certifikát - ROOT CA certifikát v .pem formáte. 
Z hľadiska prevádzky je táto možnosť lepšia, nakoľko certifikát certifikačnej autority platí aj 20 rokov a nie je nutný renew certifikátu.
Projekt je možné integrovať cez MQTT do domácej automatizácie (Hassio, Domoticz, Loxone) pre zobrazenie výšky hladiny vody vo vlastnom dashboarde.
Možnosť offline meraní (kompletne bez konektivity) s výpisom na UART rozhranie, znakové LCD displeje 16x2 / 20x4 komunikujúce cez I2C zbernicu.
</p>
<div class="alert alert-info">
	<strong>Programové implementácie pre Arduino, ESP8266, ESP32: </strong><a href="http://arduino.clanweb.eu/studna_s_prekladom/program.php">TU</a>
</div>	
<hr>
<p style="text-align: justify;">
Pre lokality, kde sa nenachádza pokrytie pevným internetom je možné využiť aj IoT sieť Sigfox, ktorá pokrýva takmer 90% Slovenska, vysielacie stanice má hlavne na Towercome vysielačoch.
Táto technológia umožňuje prenášať malé objemy správ s veľkosťou do 12B. V prípade projektu Hladinomer sa odosiela 4B hodnota výšky hladiny vody. Pre projekt rozšírený o zrážkomer sa odosiela hodnota 8B hodnota, ktorá je tvorená výškou hladiny vody a prírastkom zrážok.
Nakoľko Sigfox dovoľuje preniesť denne maximálne 140 správ, je interval odosielania dát rozšírený na 11 minút. V oboch prípadoch tak správa neobsahuje plnú dĺžku, ktorú môže, t.j. 12B. 
Payload správy je možné doplniť aj o rôzne systémové informácie, napríklad: GEO údaje (zemepisná dĺžka / šírka), RSSI (Sila prijatého signálu), číslo správy a iné.
Komunikačný modul, ktorý bol využitý pre projekt je Sigfox WISOL 868MHz UART modem. Tento modem komunikuje cez AT príkazy prostredníctvom UART rozhrania, ktoré je softvérovo emulované na mikrokontroléry.
Komunikácia preberia rýchlosťou 9600 baud/s. WISOL modem je vybavený integrovaným u.FL konektorom na PCB modulu pre pripojenie antény, ktorá výrazne zdostupní pokrytie aj v interiéri / zatienenom exteriéri.
Pre úspešný prenos dát sa vyžaduje pokrytie dvomi, najlepšie tromi a viac BTS stanicami pre úspešný prenos údajov. BTS-ky prenesenú informáciu odošlú do Sigfox backendu, kde je nutné urobiť Callback, ktorý sa spustí po prijatí dát.
Callback musí vykonať HTTP, respektíve HTTPS request na doménu, kde webaplikácia beží s POST metódou a vhodne enkódovaným payloadom, ktorý backend webaplikácie očakáva.
</p>
<div class="alert alert-info">
<h4>Nastavenie Sigfox backend callbacku pre vyskúšanie webaplikácie</h4>
<b>Hladinomer:</b>
<li>Callbacks --> Custom --> New</li>
<li><b>Do Custom payload config napíšeme:</b> cislo1::uint:16</li>
<li><b>Do URL pattern:</b> http://arduino.clanweb.eu/studna_s_prekladom/data.php (alebo iná URL adresa vašho webservera, kde bude projekt bežať), možnosť využiť i HTTPS</li>
<li><b>V HTTP metóde zvolíme:</b> POST</li>
<li><b>Do Body (tela správy) doplníme:</b></li>
<li>hodnota={customData#cislo1}&token=123456789</li>
<li><b>Do Content-Type:</b> application/x-www-form-urlencoded</li>
</div>				
<hr>
<center> 
     <h3>Screenshoty webového rozhrania pre projekt Hladinomer</h3>
     <hr>
<a href="http://arduino.clanweb.eu/studna_s_prekladom/">
<img src="https://i.imgur.com/3x1eV0R.gif" style="display: block; max-width: 100%; height: auto;" alt="Obnova posledných nameraných údajov automaticky cez AJAX - Hladinomer - Monitor výšky hladiny vody v studni" title="Obnova posledných nameraných údajov automaticky cez AJAX - Hladinomer - Monitor výšky hladiny vody v studni">
    <img src="https://i.imgur.com/g2WUChr.png" style="display: block; max-width: 100%; height: auto;" alt="Hlavný prehľad - Hladinomer - výška hladiny vody v studni" title="Hlavný prehľad - Hladinomer - výška hladiny vody v studni">
    <img src="https://i.imgur.com/E0qvrJS.png" style="display: block; max-width: 100%; height: auto;" alt="Historický prehľad nameraných údajov s časovou značkou - Hladiomer" title="Historický prehľad nameraných údajov s časovou značkou - Hladiomer"> 
    <img src="https://i.imgur.com/LocF6zH.jpg" style="display: block; max-width: 100%; height: auto;" alt="Rekordy nameraných údajov o výške hladiny vody - MAX, MIN - Hladiomer" title="Rekordy nameraných údajov o výške hladiny vody - MAX, MIN - Hladiomer"> 
 <img src="https://i.imgur.com/KFZANfa.jpg" style="display: block; max-width: 100%; height: auto;" alt="Podporovaný hardvér pre projekt Hladinomer - Arduino - Ethernet - WiFi - ESP8266 - ESP32" title="Podporovaný hardvér pre projekt Hladinomer - Arduino - Ethernet - WiFi - ESP8266 - ESP32"> 
	</a>
</center>  
<div class="alert alert-success">
  <strong>Programové implementácie pre odosielanie údajov na toto webové rozhranie.</strong>
    <li>Implementácie pre všetky tri druhy kompatibilných mikrokontrólerov sú obsiahnuté v jednom zdrojovom kóde, na základe vybratej dosky v Arduino IDE sa kompiluje tá časť programu, ktorá prislúcha danej doske.</li>
  <li><font color="red"><b>Pre Arduino je natívne zvolené DHCP (s možnosťou odkomentovania častí so statickou IPv4 adresou), defaultne zvolený Ethernet shield Wiznet W5100 (pre W5500 / ENC28J60) nutné v zdrojovom kóde odkomentovať knižnicu a zakomentovať pôvodnú Ethernet</b></font></li>
  <li><font color="#2980B9"><b>Pre ESP8266 a ESP32 je nutné v zdrojovom kóde doplniť SSID a heslo WiFi siete. Využívajú IPv4 priradenú z DHCP.</b></font></li>
   <li>V zdrojovom kóde sú použité vývody mikrokontrolérov na základe schémy zapojenia tu na stránke pre pripojenie ultrazvukového senzora vzdialenosti HC-SR04 / JSN-SR04T.</li>
   <hr>
   <h4><font color="red">Dôležité údaje vyžadujúce zmenu / pozornosť pre kompatibilitu s vašou sieťou a hardvérom sú v zdrojovom kóde vyznačené ČERVENOU FARBOU!</font></h4></div>
<pre style="background-color:#27AE60;"> 
/*|-----------------------------------------------------------------------------------|*/
/*|Projekt: Hladinomer - HTTP - Compact - HC-SR04 / JSN-SR04T / HY-SRF05              |*/
/*|Arduino + Ethernet (W5100 / W5500, ENC28J60), ESP8266 (NodeMCU), ESP32 (DevKit)    |*/
/*|Autor: Martin Chlebovec (martinius96)                                              |*/
/*|E-mail: martinius96@gmail.com                                                      |*/
/*|Info k projektu (schéma): https://martinius96.github.io/hladinomer-studna-scripty/ |*/
/*|Testovacie webove rozhranie: http://arduino.clanweb.eu/studna_s_prekladom/         |*/
/*|Knižnice NewPing, ESP8266NewPing a Ethernet2 je dostupná v Github repozitári:      |*/
/*|https://github.com/martinius96/hladinomer-studna-scripty/ - stihnuť a rozbaliť     |*/
/*|Obsah priečinka /src/ nakopírovať do C:/Users/User/Dokumenty/Arduino/libraries/    |*/
/*|Na toto webove rozhranie posiela mikrokontroler data                               |*/
/*|Na zaklade zvolenej platformy v Arduino IDE sa vykona kompilacia podla direktiv    |*/
/*|Licencia pouzitia: MIT                                                             |*/
/*|Revízia: 19. Februar 2021                                                          |*/
/*|-----------------------------------------------------------------------------------|*/

const char* host = "arduino.clanweb.eu"; //adresa webservera (doména) na ktorú sa odosielajú dáta
String url = "/studna_s_prekladom/data.php"; //URL adresa - cesta pod domenou k cieľovemu .php súboru, ktorý realizuje zápis
//Pre testovacie webove rozhranie sa data odosielaju na: arduino.clanweb.eu/studna_s_prekladom/data.php (HTTP POST ONLY)

//Kompatibilne mikrokontrolery z rady Arduino: Uno, Nano, Mega (R3)
#if defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
//HLAVICKOVE SUBORY PRE ARDUINO A ETHERNET SHIELD + watchdog
#include &lt;avr\wdt.h>
#include &lt;SPI.h>



//VOLBA ETHERNET MODULU / SHIELDU K ARDUINU Z RADY WIZNET / ENC (Microchip)
///////////////////////////////////////////////////////////////////////////////////////
<font color="red"><h5>#include &lt;Ethernet.h> //Ethernet shield Wiznet W5100 - zakomentovat ak sa nepouziva    </h5></font>
<font color="red"><h5>//#include &lt;Ethernet2.h> //Ethernet modul Wiznet W5500 - zakomentovat ak sa nepouziva   </h5></font>
<font color="red"><h5>//#include &lt;Ethernet3.h> //Ethernet modul WIZ850io / USR-ES1 (Wiznet W5500 V2) - zakomentovat ak sa nepouziva   </h5></font>
<font color="red"><h5>//#include &lt;UIPEthernet.h> //Ethernet modul ENC28J60 - zakomentovat ak sa nepouziva   </h5></font>
///////////////////////////////////////////////////////////////////////////////////////

    

//PREMENNE, HLAVICKOVY SUBOR, OBJEKT PRE HC-SR04 / JSN-SR04T
#include &lt;NewPing.h>
#define pinTrigger    5
#define pinEcho       6
#define maxVzdialenost 450
NewPing sonar(pinTrigger, pinEcho, maxVzdialenost);

byte mac[] = { 0xAA, 0xBB, 0xCA, 0xDC, 0xEE, 0xDE };
//IPAddress ip(192, 168, 0, 2);
//IPAddress dnServer(192, 168, 0, 1);
//IPAddress gateway(192, 168, 0, 1);
//IPAddress subnet(255, 255, 255, 0);
unsigned long timer = 0;
EthernetClient client;

#elif defined(ESP8266)
#include &lt;ESP8266WiFi.h>
#include &lt;NewPingESP8266.h>
#define pinTrigger    5 //D1
#define pinEcho       4 //D2
#define maxVzdialenost 450
NewPingESP8266 sonar(pinTrigger, pinEcho, maxVzdialenost);

#elif defined(ESP32)
#include &lt;WiFi.h>
#include &lt;NewPingESP8266.h>
#include "esp_system.h"
#define pinTrigger    22 //D22
#define pinEcho       23 //D23
#define maxVzdialenost 450
NewPingESP8266 sonar(pinTrigger, pinEcho, maxVzdialenost);
const int wdtTimeout = 30000;  //time in ms to trigger the watchdog
hw_timer_t *timer = NULL;

void IRAM_ATTR resetModule() {
  ets_printf("reboot\n");
  esp_restart();
}
#endif

#if defined(ESP32) || defined(ESP8266)
<font color="red"><h5>const char * ssid = "WIFI_MENO_SIETE"; //MENO WiFi SIETE</h5></font>
<font color="red"><h5>const char * password = "WIFI_HESLO_SIETE"; //HESLO WiFi SIETE</h5></font>
WiFiClient client;
unsigned long timer2 = 0;
#endif

void setup() {
  Serial.begin(115200);
#if defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
  if (Ethernet.begin(mac) == 0) {
    Serial.println(F("Konfigurujem Ethernet adapter"));
    Ethernet.begin(mac); // pre DHCP
    //Ethernet.begin(mac, ip); //pre staticku IPv4
    //Ethernet.begin(mac, ip, dns); //pre staticku IPv4
    //Ethernet.begin(mac, ip, dns, gateway); //pre staticku IPv4
    //Ethernet.begin(mac, ip, dns, gateway, subnet); //pre staticku IPv4 
    //IBA PRE Ethernet3.h !!! POZOR --> INY BEGIN ORDER PARAMETROV.... : //Ethernet.begin(mac, ip, subnet, gateway, dns);
  }
  Serial.print(F("Priradena IP: "));
  Serial.println(Ethernet.localIP());
  wdt_enable(WDTO_8S); //watchdog on 8 sec trigger
#elif defined(ESP32) || defined(ESP8266)
  WiFi.begin(ssid, password); //pripoj sa na wifi siet s heslom
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(F("."));
  }
  Serial.println("");
  Serial.println(F("Wifi pripojene s IP:"));
  Serial.println(WiFi.localIP());
#endif
#if defined(ESP8266)
  ESP.wdtEnable(30000); //30s SW watchdog
#elif defined(ESP32)
  timer = timerBegin(0, 80, true);                  //timer 0, div 80
  timerAttachInterrupt(timer, &resetModule, true);  //attach callback
  timerAlarmWrite(timer, wdtTimeout * 1000, false); //set time in us
  timerAlarmEnable(timer);                          //enable interrupt
#endif
}

void loop() {
#if defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
  wdt_reset(); //Feed watchdog
  /* if (Ethernet.begin(mac) == 0) {
    Ethernet.begin(mac); // pre DHCP
    //Ethernet.begin(mac, ip); //pre staticku IPv4
    //Ethernet.begin(mac, ip, dns); //pre staticku IPv4
    //Ethernet.begin(mac, ip, dns, gateway); //pre staticku IPv4
    //Ethernet.begin(mac, ip, dns, gateway, subnet);
  } */

  if ((millis() - timer) >= 300000 || timer == 0) { //rutina raz za 5 minut
    timer = millis();
    //NEPOUZIVAT MOMENTALNE, SPOSOBUJE PROBLEMY A ZACYKLENIE SIETE
   // Ethernet.maintain(); //pre DHCP, pri statickej IP zakomentovat
    int vzdialenost = sonar.ping_cm();
    delay(50);
    if (vzdialenost > 0) {
      vzdialenost = 0;
      for (int i = 0; i &lt; 10; i++) {
        vzdialenost += sonar.ping_cm();
        delay(50);
      }
      wdt_reset();
      vzdialenost = vzdialenost / 10;
      Serial.print(F("Vzdialenost medzi senzorom a predmetom je: "));
      Serial.print(vzdialenost);
      Serial.println(F(" cm."));
      client.stop(); //ukoncenie vsetkych existujucich spojeni
      String data = "hodnota=" + String(vzdialenost) + "&token=123456789";
      if (client.connect(host, 80)) {
        client.println("POST " + url + " HTTP/1.0");
        client.println("Host: " + (String)host);
        client.println(F("User-Agent: EthernetW5100")); //Moznost pouzit iny USER agent
        client.println(F("Connection: close"));
        client.println(F("Content-Type: application/x-www-form-urlencoded;"));
        client.print(F("Content-Length: "));
        client.println(data.length());
        client.println();
        client.println(data);
        Serial.println(F("Data uspesne odoslane na webove rozhranie"));
      } else {
        Serial.println(F("Pripojenie zlyhalo..."));
        delay(500);
        timer = 0;  //vynulujeme timer, znovu nameriame a vykoname request
      }
      client.stop();
    } else {
      Serial.println(F("Vzdialenost medzi predmetom a senzorom je mimo rozsah."));
      delay(500);
      timer = 0; //vynulujeme timer, znovu nameriame a vykoname request
    }
  }
#endif
#if defined(ESP32) || defined(ESP8266)
  if (WiFi.status() != WL_CONNECTED) {
    WiFi.begin(ssid, password); //pripoj sa na wifi siet s heslom
  }
#endif
#if defined(ESP8266)
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(F("."));
  }
  ESP.wdtFeed(); //feed watchdog
  yield(); //nechaj ESP dokoncit WiFi stack
  if ((millis() - timer2) >= 300000 || timer2 == 0) {
    timer2 = millis();
    int vzdialenost = sonar.ping_cm();
    delay(50);
    if (vzdialenost > 0) {
      vzdialenost = 0;
      for (int i = 0; i &lt; 10; i++) {
        vzdialenost += sonar.ping_cm();
        delay(50);
      }
      vzdialenost = vzdialenost / 10;
      Serial.print(F("Vzdialenost medzi senzorom a predmetom je: "));
      Serial.print(vzdialenost);
      Serial.println(F(" cm."));
      client.stop();
      String data = "hodnota=" + String(vzdialenost) + "&token=123456789";
      if (client.connect(host, 80)) {
        client.println("POST " + url + " HTTP/1.0");
        client.println("Host: " + (String)host);
        client.println(F("User-Agent: ESP8266"));
        client.println(F("Connection: close"));
        client.println(F("Content-Type: application/x-www-form-urlencoded;"));
        client.print(F("Content-Length: "));
        client.println(data.length());
        client.println();
        client.println(data);
        Serial.println(F("Data uspesne odoslane na web"));
      } else {
        Serial.println(F("Pripojenie zlyhalo..."));
        delay(500);
        timer2 = 0;  //vynulujeme timer, znovu nameriame a vykoname request
      }
      client.stop();
    }
    else {
      Serial.println(F("Vzdialenost medzi predmetom a senzorom je mimo rozsah."));
      delay(500);
      client.stop();
      timer2 = 0; //vynulujeme timer, znovu nameriame a vykoname request
    }
  }

#elif defined(ESP32)
  while (WiFi.status() != WL_CONNECTED) {
    timerWrite(timer, 0); //reset timer (feed watchdog)
    delay(500);
    Serial.print(F("."));
  }
  timerWrite(timer, 0); //reset timer (feed watchdog)
  yield(); //nechaj ESP dokoncit WiFi stack
  if ((millis() - timer2) >= 300000 || timer2 == 0) {
    timer2 = millis();
    int vzdialenost = sonar.ping_cm();
    delay(50);
    if (vzdialenost > 0) {
      vzdialenost = 0;
      for (int i = 0; i &lt; 10; i++) {
        vzdialenost += sonar.ping_cm();
        delay(50);
      }
      vzdialenost = vzdialenost / 10;
      Serial.print(F("Vzdialenost medzi senzorom a predmetom je: "));
      Serial.print(vzdialenost);
      Serial.println(F(" cm."));
      client.stop();
      String data = "hodnota=" + String(vzdialenost) + "&token=123456789";
      if (client.connect(host, 80)) {
        client.println("POST " + url + " HTTP/1.0");
        client.println("Host: " + (String)host);
        client.println(F("User-Agent: ESP32"));
        client.println(F("Connection: close"));
        client.println(F("Content-Type: application/x-www-form-urlencoded;"));
        client.print(F("Content-Length: "));
        client.println(data.length());
        client.println();
        client.println(data);
        Serial.println(F("Data uspesne odoslane na web"));
      } else {
        Serial.println(F("Pripojenie zlyhalo..."));
        delay(500);
        timer2 = 0;  //vynulujeme timer, znovu nameriame a vykoname request
      }
      client.stop();
    }
    else {
      Serial.println(F("Vzdialenost medzi predmetom a senzorom je mimo rozsah."));
      delay(500);
      client.stop();
      timer2 = 0; //vynulujeme timer, znovu nameriame a vykoname request
    }
  }
#endif
}
</pre>
<hr><h2><font color="#3498DB">HTTP - ESP8266 / ESP32 + OTA</a></font></h2><hr> 
<pre style="background-color:#3498DB;">
/*|-----------------------------------------------------------------------------------|*/
/*|Projekt: Hladinomer - HTTP - OTA - HC-SR04 / JSN-SR04T / HY-SRF05                  |*/
/*|ESP8266 (NodeMCU, Wemos D1 Mini, Generic), ESP32 (DevKit, Generic)                 |*/
/*|Autor: Martin Chlebovec (martinius96)                                              |*/
/*|E-mail: martinius96@gmail.com                                                      |*/
/*|Info k projektu (schéma): https://martinius96.github.io/hladinomer-studna-scripty/ |*/
/*|Testovacie webove rozhranie: http://arduino.clanweb.eu/studna_s_prekladom/         |*/
/*|Knižnica ESP8266NewPing je dostupná v Github repozitári:                           |*/
/*|https://github.com/martinius96/hladinomer-studna-scripty/ - stihnuť a rozbaliť     |*/
/*|Obsah priečinka /src/ nakopírovať do C:/Users/User/Dokumenty/Arduino/libraries/    |*/
/*|Na toto webove rozhranie posiela mikrokontroler data                               |*/
/*|Na zaklade zvolenej platformy v Arduino IDE sa vykona kompilacia podla direktiv    |*/
/*|Licencia pouzitia: MIT                                                             |*/
/*|Revízia: 26. Februar 2021                                                          |*/
/*|-----------------------------------------------------------------------------------|*/
      
#include &lt;WiFiUdp.h>
#include &lt;ArduinoOTA.h>
#include &lt;NewPingESP8266.h>

<font color="red"><h5>const char * ssid = "WIFI_MENO_SIETE"; //MENO WiFi SIETE</h5></font>
<font color="red"><h5>const char * password = "WIFI_HESLO_SIETE"; //HESLO WiFi SIETE</h5></font>
const char* host = "arduino.clanweb.eu"; //adresa webservera (doména) na ktorú sa odosielajú dáta
String url = "/studna_s_prekladom/data.php"; //URL adresa - cesta pod domenou k cieľovemu .php súboru, ktorý realizuje zápis
//Pre testovacie webove rozhranie sa data odosielaju na: arduino.clanweb.eu/studna_s_prekladom/data.php (HTTP POST ONLY)
unsigned long timer2 = 0;
#if defined(ESP32)
#include &lt;WiFi.h>
#include &lt;ESPmDNS.h>
#include "esp_system.h"
#define pinTrigger    22
#define pinEcho       23
#define maxVzdialenost 450
NewPingESP8266 sonar(pinTrigger, pinEcho, maxVzdialenost);

const int wdtTimeout = 30000;  //time in ms to trigger the watchdog
hw_timer_t *timer = NULL;

void IRAM_ATTR resetModule() {
  ets_printf("reboot\n");
  esp_restart();
}

#elif defined(ESP8266)
#include &lt;ESP8266WiFi.h>
#include &lt;ESP8266mDNS.h>
#include &lt;ArduinoOTA.h>
#include &lt;NewPingESP8266.h>
#define pinTrigger    5 //D1
#define pinEcho       4 //D2
#define maxVzdialenost 450
NewPingESP8266 sonar(pinTrigger, pinEcho, maxVzdialenost);
#endif
WiFiClient client;
void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password); //pripoj sa na wifi siet s heslom
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(".");
  }
  ArduinoOTA.onStart([]() {
    Serial.println(F("Start"));
  });
  ArduinoOTA.onEnd([]() {
    Serial.println(F("\nEnd"));
  });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
  });
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
    else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
    else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
    else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
    else if (error == OTA_END_ERROR) Serial.println("End Failed");
  });
  ArduinoOTA.begin();
  Serial.println(F(""));
  Serial.println(F("Wifi pripojene s IP:"));
  Serial.println(WiFi.localIP());
#if defined(ESP32)
  timer = timerBegin(0, 80, true);                  //timer 0, div 80
  timerAttachInterrupt(timer, &resetModule, true);  //attach callback
  timerAlarmWrite(timer, wdtTimeout * 1000, false); //set time in us
  timerAlarmEnable(timer);                          //enable interrupt
#elif defined(ESP8266)
  ESP.wdtEnable(30000);
#endif
}

void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    WiFi.begin(ssid, password); //pripoj sa na wifi siet s heslom
  }
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
#if defined(ESP32)
  timerWrite(timer, 0); //reset timer (feed watchdog)
#elif defined(ESP8266)
  ESP.wdtFeed();
#endif
  ArduinoOTA.handle();
  yield();
  if ((millis() - timer2) >= 300000 || timer2 == 0) {
    timer2 = millis();
    int vzdialenost = sonar.ping_cm();
    delay(50);
    if (vzdialenost > 0) {
      vzdialenost = 0;
      for (int i = 0; i &lt; 10; i++) {
        vzdialenost += sonar.ping_cm();
        delay(50);
      }
      vzdialenost = vzdialenost / 10;
      Serial.print(F("Vzdialenost medzi senzorom a predmetom je: "));
      Serial.print(vzdialenost);
      Serial.println(F(" cm."));
      String data = "hodnota=" + String(vzdialenost) + "&token=123456789";
      if (client.connect(host, 80)) {
        client.println("POST " + url + " HTTP/1.0");
        client.println("Host: " + (String)host);
        client.println(F("User-Agent: ESP"));
        client.println(F("Connection: close"));
        client.println(F("Content-Type: application/x-www-form-urlencoded;"));
        client.print(F("Content-Length: "));
        client.println(data.length());
        client.println();
        client.println(data);
        Serial.println(F("Data uspesne odoslane na web"));
      } else {
        Serial.println(F("Pripojenie zlyhalo..."));
        delay(500);
        timer2 = 0; //reset pocitadla, vykoname opakovany request
      }
    }
    else {
      Serial.println(F("Vzdialenost medzi predmetom a senzorom je mimo rozsah."));
      delay(500);
      timer2 = 0; //reset pocitadla, vykoname opakovany request
    }
    client.stop();
  }
}
</pre> 
<hr><h2><font color="#95A5A6">HTTP - ESP8266 / ESP32 + ULP - Deep Sleep</a></font></h2><hr>
<div class="alert alert-danger">
<font color="red"><b>Pri ESP8266 (NodeMCU, Wemos D1 Mini, Generic) je nutné prepojiť RST S GPIO16 (D0) po nahratí programu a vykonať reštart cez EN (RST) tlačidlo, inak prebudenie a Deep Sleep nebude fungovať!</b></font> 
</div>
<pre style="background-color:#95A5A6;">
/*|-----------------------------------------------------------------------------------|*/
/*|Projekt: Hladinomer - HTTP - ULP - DEEP SLEEP - HC-SR04 / JSN-SR04T / HY-SRF05     |*/
/*|ESP8266 (NodeMCU, Wemos D1 Mini, Generic), ESP32 (DevKit, Generic)                 |*/
/*|Autor: Martin Chlebovec (martinius96)                                              |*/
/*|E-mail: martinius96@gmail.com                                                      |*/
/*|Info k projektu (schéma): https://martinius96.github.io/hladinomer-studna-scripty/ |*/
/*|Testovacie webove rozhranie: http://arduino.clanweb.eu/studna_s_prekladom/         |*/
/*|Knižnica ESP8266NewPing je dostupná v Github repozitári:                           |*/
/*|https://github.com/martinius96/hladinomer-studna-scripty/ - stihnuť a rozbaliť     |*/
/*|Obsah priečinka /src/ nakopírovať do C:/Users/User/Dokumenty/Arduino/libraries/    |*/
/*|Na toto webove rozhranie posiela mikrokontroler data                               |*/
/*|Na zaklade zvolenej platformy v Arduino IDE sa vykona kompilacia podla direktiv    |*/
/*|Licencia pouzitia: MIT                                                             |*/
/*|Revízia: 26. Februar 2021                                                          |*/
/*|-----------------------------------------------------------------------------------|*/
<font color="red"><h5>const char * ssid = "WIFI_MENO_SIETE"; //MENO WiFi SIETE</h5></font>
<font color="red"><h5>const char * password = "WIFI_HESLO_SIETE"; //HESLO WiFi SIETE</h5></font>
const char* host = "arduino.clanweb.eu"; //adresa webservera (doména) na ktorú sa odosielajú dáta
String url = "/studna_s_prekladom/data.php"; //URL adresa - cesta pod domenou k cieľovemu .php súboru, ktorý realizuje zápis
//Pre testovacie webove rozhranie sa data odosielaju na: arduino.clanweb.eu/studna_s_prekladom/data.php (HTTP POST ONLY)

#include &lt;NewPingESP8266.h>
#if defined(ESP32)
#define uS_TO_S_FACTOR 1000000  /* Conversion factor for micro seconds to seconds */
#define TIME_TO_SLEEP  300        /* Time ESP32 will go to sleep (in seconds) */
#include &lt;WiFi.h>
#define pinTrigger    22
#define pinEcho       23
#define maxVzdialenost 450
#elif defined(ESP8266)
#include &lt;ESP8266WiFi.h>
#define pinTrigger    5 //D1
#define pinEcho       4 //D2
#define maxVzdialenost 450
#endif

NewPingESP8266 sonar(pinTrigger, pinEcho, maxVzdialenost);

WiFiClient client;
void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password); //pripoj sa na wifi siet s heslom
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(F("."));
  }
  Serial.println(F(""));
  Serial.println(F("Wifi pripojene s IP:"));
  Serial.println(WiFi.localIP());
  int vzdialenost = sonar.ping_cm();
  delay(50);
  if (vzdialenost > 0) {
    vzdialenost = 0;
    for (int i = 0; i &lt; 10; i++) {
      vzdialenost += sonar.ping_cm();
      delay(50);
    }
    vzdialenost = vzdialenost / 10;
    Serial.print(F("Vzdialenost medzi senzorom a predmetom je: "));
    Serial.print(vzdialenost);
    Serial.println(F(" cm."));
    String data = "hodnota=" + String(vzdialenost) + "&token=123456789";
    client.stop();
    if (client.connect(host, 80)) {
      client.println("POST " + url + " HTTP/1.0");
      client.println("Host: " + (String)host);
      client.println(F("User-Agent: ESP"));
      client.println(F("Connection: close"));
      client.println(F("Content-Type: application/x-www-form-urlencoded;"));
      client.print(F("Content-Length: "));
      client.println(data.length());
      client.println();
      client.println(data);
      Serial.println(F("Data uspesne odoslane na web"));
    } else {
      Serial.println(F("Pripojenie zlyhalo..."));
    }
  }
  else {
    Serial.println(F("Vzdialenost medzi predmetom a senzorom je mimo rozsah."));
  }
  client.stop();
#if defined(ESP32)
  esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);
  Serial.println("Setup ESP32 to sleep for every " + String(TIME_TO_SLEEP) + " Seconds");
  esp_deep_sleep_start();
#elif defined(ESP8266)
  Serial.println(F("Entering deep sleep mode for 300 seconds"));
  ESP.deepSleep(300e6);
#endif
}

void loop() {

}
</pre>
<hr><h2><font color="#E67E22">Sigfox UART MODEM 868MHz - Arduino - Sigfox Backend</a></font></h2><hr>
<pre style="background-color:#E67E22;">
/*|-----------------------------------------------------------------------------------|*/
/*|Projekt: Hladinomer - HTTP - Sigfox 868 MHz UART - HC-SR04 / JSN-SR04T / HY-SRF05  |*/
/*|Arduino, ESP8266 (NodeMCU), ESP32 (DevKit)                                         |*/
/*|Autor: Martin Chlebovec (martinius96)                                              |*/
/*|E-mail: martinius96@gmail.com                                                      |*/
/*|Info k projektu (schéma): https://martinius96.github.io/hladinomer-studna-scripty/ |*/
/*|Testovacie webove rozhranie: http://arduino.clanweb.eu/studna_s_prekladom/         |*/
/*|Knižnice NewPing, ESP8266NewPing sú dostupné v Github repozitári:                  |*/
/*|https://github.com/martinius96/hladinomer-studna-scripty/ - stihnuť a rozbaliť     |*/
/*|Obsah priečinka /src/ nakopírovať do C:/Users/User/Dokumenty/Arduino/libraries/    |*/
/*|Na toto webove rozhranie posiela mikrokontroler data                               |*/
/*|Na zaklade zvolenej platformy v Arduino IDE sa vykona kompilacia podla direktiv    |*/
/*|Licencia pouzitia: MIT                                                             |*/
/*|Revízia: 26. Februar 2021                                                          |*/
/*|-----------------------------------------------------------------------------------|*/

/*|---------------------------------------------------------------------|*/
/*|Inštrukcie pre nastavenie Sigfox Modemu na stránkach Sigfox backend: |*/
/*|Callbacks --> NEW --> Custom callback                                |*/
/*|UPLINK, TYPE: DATA, CHANNEL: URL                                     |*/
/*|Do Custom payload config napíšeme: cislo1::uint:16                   |*/
/*|Do URL pattern: http://arduino.clanweb.eu/studna_s_prekladom/data.php|*/
/*|PRIPADNE: (pripadne vas URL webservera s možnostou TLS - SSL)        |*/
/*|V HTTP metóde zvolíme: POST (jediná podporovaná metóda Hladinomeru)  |*/
/*|Do Body (tela správy) doplníme:                                      |*/
/*|hodnota={customData#cislo1}&token=123456789                          |*/
/*|Mozno odosielat aj systemove udaje - cislo spravy, RSSI, GEO UDAJE   |*/
/*|Do Content-Type: application/x-www-form-urlencoded                   |*/
/*|---------------------------------------------------------------------|*/

//HLAVICKOVE SUBORY watchdog a software serial
#include &lt;avr\wdt.h>
#include &lt;SoftwareSerial.h>

// nastavenie softverovej zbernice pre Sigfox Modem
#define TX 7
#define RX 8
SoftwareSerial Sigfox(RX, TX);

//PREMENNE, HLAVICKOVY SUBOR, OBJEKT PRE HC-SR04 / JSN-SR04T
#include &lt;NewPing.h>
//#include &lt;NewPingESP8266.h> // pre ESP8266, ESP32
#define pinTrigger    5
#define pinEcho       6
#define maxVzdialenost 450
NewPing sonar(pinTrigger, pinEcho, maxVzdialenost);
//NewPingESP8266 sonar(pinTrigger, pinEcho, maxVzdialenost); // pre ESP8266, ESP32
unsigned long timer = 0;


void setup() {
  Sigfox.begin(9600); //SoftwareSerial
  Serial.begin(115200);
  wdt_enable(WDTO_8S);
}

void loop() {
  wdt_reset();
  if (Sigfox.available()) {
    Serial.write(Sigfox.read()); //MOZNO VYSKUSAT AT prikaz, odpoved OK
  }
  if (Serial.available()) {
    Sigfox.write(Serial.read());
  }
  if ((millis() - timer) >= 660000 || timer == 0) { //rutina raz za 11 minut (limit 140 sprav za den), odosle sa 130 správ za deň (24h)
    timer = millis();
    Sigfox.println(); //Wakeup from Light sleep via ‘\n’ (ASCII 10)
    //Sigfox.print('\n'); //Wakeup from Light sleep via ‘\n’ (ASCII 10) - ekvivalent
    unsigned int vzdialenost = sonar.ping_cm();
    delay(50);
    if (vzdialenost > 0) {
      vzdialenost = 0;
      for (int i = 0; i &lt; 10; i++) {
        vzdialenost += sonar.ping_cm();
        delay(50);
      }
      wdt_reset();
      vzdialenost = vzdialenost / 10;
      Serial.print(F("Vzdialenost medzi senzorom a predmetom je: "));
      Serial.print(vzdialenost);
      Serial.println(F(" cm."));
      char sprava[4]; //4B sprava, max mozna 12B
      unsigned int cislo1 = vzdialenost;
      sprintf(sprava, "%04X", cislo1);
      Serial.print(F("Do Sigfox siete odosielam tento payload: "));
      Serial.print(cislo1);
      Serial.print(F(", hexa tvar: "));
      Serial.println(sprava);
      wdt_reset();
      Sigfox.print(F("AT$SF="));
      Sigfox.println(sprava);
      wdt_reset();
      delay(1000);
      Sigfox.print(F("AT$P=1")); //Light sleep (Send a break (‘\n’) to wake up.)
      //Sigfox.print(F("AT$P=2")); //Deep sleep (power-on reset needed for wake up)
    } else {
      Serial.println(F("Vzdialenost medzi predmetom a senzorom je mimo rozsah."));
      timer = 0; //vynulujeme timer, vykoname nove meranie
    }
  }
}
  </pre> 
  <hr><h2><font color="#CD6155">Espressif IoT Development Framework (ESP-IDF) v4.X - ESP32 - HTTP</a></font></h2><hr>
<pre style="background-color:#CD6155;">
/*|-----------------------------------------------------------------------------------|*/
/*|Projekt: Hladinomer - HTTP - HC-SR04 / JSN-SR04T / HY-SRF05                        |*/
/*|ESP32 (DevKit, Generic) - ESP-IDF v4.2 (4.0 compatible)                            |*/
/*|Autor: Martin Chlebovec (martinius96)                                              |*/
/*|E-mail: martinius96@gmail.com                                                      |*/
/*|Info k projektu (schéma): https://martinius96.github.io/hladinomer-studna-scripty/ |*/
/*|Testovacie webove rozhranie: http://arduino.clanweb.eu/studna_s_prekladom/         |*/
/*|Revízia: 4. Jun 2021                                                               |*/
/*|-----------------------------------------------------------------------------------|*/

/* HTTP GET Example using plain POSIX sockets

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/
#include &lt;string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "protocol_examples_common.h"

#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include "lwip/netdb.h"
#include "lwip/dns.h"

#include "ultrasonic.h"
#include "driver/dac.h"

/* Constants that aren't configurable in menuconfig */

#define MAX_DISTANCE_CM 450 // 5m max
#define GPIO_TRIGGER	22
#define GPIO_ECHO	23
// Webserver
#define WEB_SERVER "arduino.clanweb.eu"
#define WEB_PORT "80"


static const char *TAG = "http_request";
static const char *TAG2 = "ultrasonic_measurement";

QueueHandle_t  q=NULL;
static void ultrasonic(void *pvParamters)
{
	ultrasonic_sensor_t sensor = {
		.trigger_pin = GPIO_TRIGGER,
		.echo_pin = GPIO_ECHO
	};

	ultrasonic_init(&sensor);
  uint32_t distance = 0;
    if(q == NULL){
        printf("Queue is not ready \n");
        return;
    }
	while (true) {
  uint32_t avg_distance = 0;
  int index_loop = 1;
  while(index_loop&lt;=10){
		esp_err_t res = ultrasonic_measure_cm(&sensor, MAX_DISTANCE_CM, &distance);
		if (res != ESP_OK) {
			printf("Error: ");
			switch (res) {
				case ESP_ERR_ULTRASONIC_PING:
					printf("Cannot ping (device is in invalid state)\n");
					break;
				case ESP_ERR_ULTRASONIC_PING_TIMEOUT:
					printf("Ping timeout (no device found)\n");
					break;
				case ESP_ERR_ULTRASONIC_ECHO_TIMEOUT:
					printf("Echo timeout (i.e. distance too big)\n");
					break;
				default:
					printf("%d\n", res);
			}
		} else {
			printf("Measurement %d: %d cm\n", index_loop, distance);
       avg_distance +=  distance;
      index_loop++;
		}
    }
      avg_distance = avg_distance / 10;
      distance  = avg_distance;
    xQueueSend(q,(void *)&distance,(TickType_t )0); // add the counter value to the queue
            for(int countdown = 300; countdown >= 0; countdown--) {
            ESP_LOGI(TAG2, "%d... ", countdown);
            vTaskDelay(1000 / portTICK_PERIOD_MS);
        }
	}
}

static void http_get_task(void *pvParameters)
{
    const struct addrinfo hints = {
        .ai_family = AF_INET,
        .ai_socktype = SOCK_STREAM,
    };
    struct addrinfo *res;
    struct in_addr *addr;
    int s, r;
    char recv_buf[64];
    uint32_t distance;
     if(q == NULL){
        printf("Queue is not ready \n");
        return;
    }
    while(1) {
    xQueueReceive(q,&distance,(TickType_t )(350000/portTICK_PERIOD_MS)); 
    char REQUEST [1000];
	char values [250];
	sprintf(values, "hodnota=%d&token=123456789", distance);
  sprintf (REQUEST, "POST /studna_s_prekladom/data.php HTTP/1.0\r\nHost: "WEB_SERVER":"WEB_PORT"\r\nUser-Agent: ESP32\r\nConnection: close\r\nContent-Type: application/x-www-form-urlencoded;\r\nContent-Length:%d\r\n\r\n%s\r\n",strlen(values),values);
        int err = getaddrinfo(WEB_SERVER, WEB_PORT, &hints, &res);

        if(err != 0 || res == NULL) {
            ESP_LOGE(TAG, "DNS lookup failed err=%d res=%p", err, res);
            vTaskDelay(1000 / portTICK_PERIOD_MS);
            continue;
        }

        /* Code to print the resolved IP.

           Note: inet_ntoa is non-reentrant, look at ipaddr_ntoa_r for "real" code */
        addr = &((struct sockaddr_in *)res->ai_addr)->sin_addr;
        ESP_LOGI(TAG, "DNS lookup succeeded. IP=%s", inet_ntoa(*addr));

        s = socket(res->ai_family, res->ai_socktype, 0);
        if(s &lt; 0) {
            ESP_LOGE(TAG, "... Failed to allocate socket.");
            freeaddrinfo(res);
            vTaskDelay(1000 / portTICK_PERIOD_MS);
            continue;
        }
        ESP_LOGI(TAG, "... allocated socket");

        if(connect(s, res->ai_addr, res->ai_addrlen) != 0) {
            ESP_LOGE(TAG, "... socket connect failed errno=%d", errno);
            close(s);
            freeaddrinfo(res);
            vTaskDelay(4000 / portTICK_PERIOD_MS);
            continue;
        }

        ESP_LOGI(TAG, "... connected");
        freeaddrinfo(res);

        if (write(s, REQUEST, strlen(REQUEST)) &lt; 0) {
            ESP_LOGE(TAG, "... socket send failed");
            close(s);
            vTaskDelay(4000 / portTICK_PERIOD_MS);
            continue;
        }
        ESP_LOGI(TAG, "... socket send success");

        struct timeval receiving_timeout;
        receiving_timeout.tv_sec = 5;
        receiving_timeout.tv_usec = 0;
        if (setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &receiving_timeout,
                sizeof(receiving_timeout)) &lt; 0) {
            ESP_LOGE(TAG, "... failed to set socket receiving timeout");
            close(s);
            vTaskDelay(4000 / portTICK_PERIOD_MS);
            continue;
        }
        ESP_LOGI(TAG, "... set socket receiving timeout success");

        /* Read HTTP response */
        do {
            bzero(recv_buf, sizeof(recv_buf));
            r = read(s, recv_buf, sizeof(recv_buf)-1);
            for(int i = 0; i &lt; r; i++) {
                putchar(recv_buf[i]);
            }
        } while(r > 0);

        ESP_LOGI(TAG, "... done reading from socket. Last read return=%d errno=%d.", r, errno);
        close(s);
        ESP_LOGI(TAG, "Starting again!");
    }
}

void app_main(void)
{
    ESP_ERROR_CHECK( nvs_flash_init() );
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());

    /* This helper function configures Wi-Fi or Ethernet, as selected in menuconfig.
     * Read "Establishing Wi-Fi or Ethernet Connection" section in
     * examples/protocols/README.md for more information about this function.
     */
    ESP_ERROR_CHECK(example_connect());
     q=xQueueCreate(20,sizeof(unsigned long));
    if(q != NULL){
        printf("Queue is created\n");
        vTaskDelay(1000/portTICK_PERIOD_MS); //wait for a second
        xTaskCreate(&ultrasonic, "ultrasonic", 2048, NULL, 5, NULL);
        printf("producer task  started\n");
        xTaskCreate(&http_get_task, "http_get_task", 4096, NULL, 5, NULL);
        printf("consumer task  started\n");
    }else{
        printf("Queue creation failed");
    }    

}



</pre>
        </div>
            <hr>
	<center> 
     <h3>Detekčná charakteristika senzora HC-SR04 - 15°</h3>
     <hr>
    <img src="https://i.imgur.com/ySEAjWi.png" style="display: block; max-width: 100%; height: auto;" alt="Hladinomer - HC-SR04 detekčná charakteristika - ultrazvukový senzor vzdialenosti" title="Hladinomer - HC-SR04 detekčná charakteristika - ultrazvukový senzor vzdialenosti">
    <hr>
     <h3>Detekčná charakteristika senzora JSN-SR04T - vodotesný - 45°</h3>
     <hr>
    <img src="https://i.imgur.com/qCSLUjw.png" style="display: block; max-width: 100%; height: auto;" alt="Hladinomer - JSN-SR04T detekčná charakteristika - ultrazvukový senzor vzdialenosti" title="Hladinomer - JSN-SR04T detekčná charakteristika - ultrazvukový senzor vzdialenosti"> 
 </center>	
	<hr>
<center> 
	
 </div>
		</div>
</div>
</body>
</html>
